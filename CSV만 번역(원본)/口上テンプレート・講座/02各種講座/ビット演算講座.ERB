-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【南蛮貿易で学ぶビット演算講座】
-------------------------------------------------------------------------------

～もくじ～
１、論理演算子
２、STAIN変数
３、ビットの立て方、寝かせ方
４、ビット演算を使ったイベントについて
５、終わりに

６、후書き
７、補講


案内役紹介＞

本田さん … 何故かeraに精通しているおじいちゃんです
アントーニョさん … 何故か입上書きに目覚めたらしい親分です

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【論理演算子】
-------------------------------------------------------------------------------


『なぁなぁ本田、ちょっと聞いてもええ？』
「おやアントーニョさん。薮から棒に一体何事ですか？」
『いや、입上のお손本は입上やってフランシスが言うとったから、
　ちょっとフェリちゃんの입上覗いて見たんやけど……』


IF CFLAG:208 & 1
	PRINTFORML 「じゃーん。前にもらった奴着てみたよー。恥ずかしいけど似合ってるかなー」


『って記述があったんや。このIF条件式、&が一個しかないやん。&&の間違いとちゃうの？』
「ああ……これは論理演算子ですよ」
『ロンリエンザンシ？　ロリコンの仲間？』
「……本気でそう仰っているなら私は説明責任を放棄させて頂きます」
『嘘やって嘘！　エスパーニャジョーク！！　やから教えたってええええええ！！』
「そう言われては仕方有りませんね。ご説明致しましょう。
　まず、ビット演算という言葉に聞き覚えはありますか？」
『ビット演算って……アレやろ？　ロヴィ입上で使われとるらしい意味不明の新技術。
　アレのせいで一気にあの입上の解読難易度が跳ね上がっとんねん。俺にはさっぱりや』
「別に新技術ではないですよ。初代erakanon時代から存在した技術です」
『へーそうなん？　で、そのビット演算がどうかしたんか？』
「はい。論理演算子は、ビット演算を行う際に用いられる計算式なんですよ」
『ん……？』
「この計算式で使われる記号は|と&。
　입上やパッチ制作をしている方なら、どちらも見覚えは有りますよね」
『||は「どちらかを満たす」、&&は「両方を満たす」条件式やったな』
「ええ。それは論理演算子でも同じことです。少し例を挙げてみましょうか」

 4 &  4 == 4
 7 &  7 == 7
 8 &  2 == 0
16 &  4 == 0

『&は同じ数字やったら同じで、違う数字やと０になるん？』
「では、次にこちらをご覧下さい」

 2 |  2 == 2
 4 |  4 == 4
 7 |  2 == 7
 4 |  5 == 5

『同じ数字やったら同じのを返しとるけども、違う時は大きい方を返しとるな』
「では、再び&の場合をどうぞ」

 6 &  2 == 2
 4 & 13 == 4

『ん？　……えーと、違う数字やのに数字が小さい方を返しとる？』
「続きましてまたもや&です」

 9 & 17 == 1
21 &  7 == 5

『……へ？』
「それでは最후にもうひとつ、|の場合を見てみましょう」

21 |  7 == 23
11 | 28 == 31


『ちょ、ちょっと待ったぁ！　さっぱり意味解らんで！？』
「それでも、これは最初に言った通りなんですよ。
　|ならどちらかを満たした結果、&なら両方を満たした結果を返しています」
『はぁ？　21と7のどっちかを満たした時、でなんで23になるねん！』
「何故ならば、この計算式は全て二進数で行われているからです」
『……は？』
「そうですね……ここから先は長い説明になりますし、まずは一息入れましょうか」
『ああ、頼むわ。頭こんがらがってきた……』
「ふふ……では、私はお茶でも煎れてきますね」
『おおきに。俺の分は砂糖大盛で頼むわー』
「……え、緑茶に？」


＜느긋하게한다＞



『ふう。そろそろ落ち着いてきたし、さっきの話の続きをしてもろてもええかな？』
「論理演算子では二進数で計算を行っている……ここまでは説明しましたね。
　それでは、さっきの計算式をいくつかピックアップして二進数に直してみましょうか。
　まずは&の場合から」


  4 &   4 ==   4
100 & 100 == 100

   8 &    2 ==    0
1000 & 0010 == 0000

   4 &   13 ==    4
0100 & 1101 == 0100

   21 &     7 ==     5
10101 & 00111 == 00101

「&の動きは&&と同じ。両方を満たしたときにだけ1を返します」
『……んー、と。1が残せんのは、右の数字と左の数字が両方とも1の時だけやな』
「そういう事ですね。0と1、1と0、0と0は全てゼロになります。では、今度は|の場合」


  4 |   4 ==   4
100 | 100 == 100

  7 |   2 ==   7
111 | 010 == 111

   21 |     7 ==    23
10101 | 00111 == 10111

   11 |    28 ==    31
01011 | 11100 == 11111

『今度は、どっちかに1があったら1がそのまま残っとるな』
「|は『どちらかを満たしている』という記号ですから。0と0以外絶対に1です。
　二つの法則をまとめるとこんな感じになります」

「OR（記号・|）」
2つの数値のうちどちらかが1だった場合は1、両方とも0だった場合は0にする。
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0

「AND(記号・&)」
2つの数値のうち両方が1だった場合は1、片方でも0だった場合は0にする。
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0

「これで、意味不明な計算式の謎は解けましたね。
　解らない方は、こんなふうに筆算してみると何かをつかめるかもしれませんよ」

    4   110        21  10101
 & 13  1101      |  7  00111
-----------     ------------
    4  0100        23  10111


『ここまでは解ったけども……こんなんいちいちやっとったら疲れへん？
　21とかならまだええやろうけど、ロヴィ입上には16384とかアホな数字が出とったで？』
「二進数狂になりつつあるロヴィーノ君입上作者ならともかく、
　普通はいちいち数えてたら発狂しますね。関数電卓でも使って下さい」
『かんすう……電卓？　あかん、また未知のツールが……』
「いえ、全てのプログラム→악세사리→電卓で行ける普通の電卓ですよ。
　この電卓には10進数を２進数に直してくれる機能が付いてるんです。
　機械の方が早くて正確ですので是非ともそちらをご利用下さい」
『それなら安心やね。で、また説明して貰ってもええかな』
「どうぞ」
『この論理演算子が、どうしてビット演算に繋がるん？』
「まず、&を使えばその数字を二進数に直したときに何桁目が1かを調べることが出来ます。
　ここまでは理解して頂けましたか？」
『それはまぁ。例えば3桁目が1かどうかを調べたいんなら、
　IF A & 4って聞けばええんやろ』
「その通りです。そして、今まで説明しておりませんでしたが――
　この計算式では、『何桁目』かを『何ビット目』と呼びます」
『ん？　つまり、ビット演算っていうのは……』
「論理演算子を用いて、各ビットが1か0かを調べる為の式。ということになりますね」
『へーそうなん！　やっとビット演算の仕組みが解ったで！　いやー、ここまで長かっ……』
「おや。まだまだ終わりませんよ？」
『え』
「ここで終わったらIF条件式しか書けないじゃないですか。
　貴方、CFLAG:200の15ビット目を立てて12ビット目を寝かせて下さいって言われた時に
　どうすればいいか理解してますか？」
『その前に、ビットを立てるってなに？』
「ほら、やっぱりその程度でしょう。まだまだ解説は続きますよ、しゃっきりして下さいな」
『えー……俺もう帰りたいわぁ……』



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【STAIN変数】
-------------------------------------------------------------------------------

「それではまず、つい先ほど言っていたビットが立つ、及び寝るの意味について。
　ビット演算は二進数で進んでいきますから、当然各ビットの数字は0か1かしかありません」
『せやなぁ』
「2つしかない――逆を言えば、スイッチのON・OFFのように数字を扱える」
『お？』
「例えば5。5は二進数で表せば101です。これはスイッチ1と3がONで、2がOFFだと思えばいい。
　このスイッチがONになっている状態を、『ビットが立っている』と呼びます」
『じゃあ、0――スイッチがOFFん時は』
「はい。これは2ビット目が寝ている、もしくは落ちていると呼びます。
　――ああ、このスイッチもといビット数は右から順番に数えてくださいね。
　左から数えると残念な数字になりますよ」
『はぁー、うまく出来とんなー……でもこれ、何の役に立つん？』
「これは初代erakanon時代から存在する伝統技術ですからね、私たちの身近な所に転がっています。
　例えばSTAIN変数」
『STAIN……って、汚れやな。まぁ俺にはあんま関係ないけど』
「全国の主人と助손の憧れ素質・더러움무시持ちですからね……。
　さてさて、このSTAIN変数ですが、実はビット演算を使って判定されています」
『えええ？　そんなん初耳なんやけど』
「公式のerabasic構文解説の一番下にこっそり載ってるんですけどね。
　まずは、資料フォルダに内封されているerahetaAのSTAIN変数解説を読んでみましょうか」


汚れ一覧
STAIN:0 = 입
STAIN:1 = 손
STAIN:2 = 페니스
STAIN:3 = 바기나
STAIN:4 = 애널
STAIN:5 = 가슴
STAIN:6 = 질내

1 = 愛液
2 = 페니스
4 = 精液
8 = 애널
16= 모유
32= 粘液
64= 破瓜の血


「……と、こんな感じですね。ちなみに隠しパラメータとしてSTAIN:7で발の汚れが判定できます」
『풋잡フェチのどっかの誰かが勝손につけたした奴やな』
「발の汚れは신발を脱いだり履いたりするとリセットされますよ――とまぁ余談は置いておいて。
　この愛液汚れなどに割り当てられている数字を、ちょっと関数電卓で二進数に直してみてください」
『へ？　まぁええけど……えっと、32は――』


愛液  =   1 =          1
페니스=   2 =         10
精液  =   4 =        100
애널=   8 =       1000
모유  =  16 =      10000
破瓜血=  32 =     100000
粘液  =  64 =    1000000
尿    = 128 =   10000000
水    = 256 =  100000000
便    = 512 = 1000000000


『――あれ？　これ、綺麗に1ビットずつずれとる？』
「ええ。STAIN変数は各汚れを二進数の桁ごとに管理しているんです。
　ビット演算がスイッチのようなものだ、という事は先程説明しましたね？
　それではここで問題です。STAIN:7 == 6の時に付いている汚れは何でしょう」
『6は二進数で110やから……2、3ビット目がオンで、1がオフ。ってことは……페니스と精液の汚れやな』
「ご明答です。ここで先程教えた、何桁目が1になっているか――
　もとい、何ビット目が立っているかを求める条件式を使ってみましょうか。
　입に精液の汚れが付いているかどうか、判定してみてください」
『任しとき！　精液汚れは4やから……』

IF STAIN:0 & 4
	PRINT 精液ついとるよ！
ELSE
	PRINT 精液ついてへんよ！
ENDIF

『こんな感じで判定できるわけやな！』
「はい。また、綺麗に1ビットずつズレているので複合の汚れを判定するのにも便利なんですよ」
『STAIN:6 & 37とかロマン溢れる汚れも一気に判定できるしなぁ』
「……えー、その疑惑の判定に関してはノーコメントでいきたいと思います。
　ここでアントーニョさんが何の汚れを判定したのかは皆さんへの宿題ということで」
『さっきから散々フェチくさい汚れ判定させといて今さら何純情ぶってんねんお前……』



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【ビットの立て方、寝かせ方】
-------------------------------------------------------------------------------

「ここまでは、ゲーム中に勝손に立ったり寝たりするビットの判定について説明してきました。
　さて、ここらで一つEVENT_K2_ALL.ERBを開いて見てください。
　最初に貴方から話を聞いた時は意味不明だの解読難易度が跳ね上がってるだのと言ってましたが、
　この講座を読む前より、何が起きているか解りやすくなったように思いませんか？」
『――ホンマや。CFLAG使用表、今までは何の暗号やと思っとったけど……今なら解るわ。
　これ、STAIN変数みたいにいろんなフラグを一つの変数で管理しとるんやな？』
「はい。この입上では普通にやってるとCFLAGをすぐ枯渇させてしまうだろうと思ったので、
　まとめられる限りのフラグは全てビット演算で処理してたんですよ」
『なるほどなー。確かにこれはないわ。ビット演算なしやったら、フラグが何個あっても발らんで』
「でしょう？　ビット演算を使えば、これだけたくさんの情報も1つのCFLAGで管理できるんです。
　それではいよいよ、自分たちの손でビットを立てたり寝かせたりしてみましょうか」
『またなんか変な計算式とかが出るん？　俺、IF-ENDIFだけでいっぱいいっぱいやで？』
「IF-ENDIFだけで十分ですよ。全部발し算で出来ますから」
『え？　そうなん？』
「はい。例えば2ビット目を立てたければ……」

SIF (A & 2) == 0
	A += 2

「これで立ちます。2ビット目が立ってるのにさらに2を발しちゃうとビットがズレちゃうので、
　先に2ビット目が立ってるか立ってないかどうかを調べておくのがミソですね」
『なぁなぁ、最初のフェリちゃん입上の時も思ったんやけど、何でカッコでくくっとんの？
　A & 2 == 0じゃあかんの？』
「それが駄目なんですよ。アントーニョさん、35 + 4 % 2ってどう計算します？」
『そんなん決まっとるやん。まずは割り算からやから、4 % 2を先に計算して――あ』
「……はい。この式、仕様で2 == 0を先に計算しちゃうんで、どう발掻いても分岐しなくなるんですよ」
『成程なぁ。じゃあ、カッコでくくんのは忘れんようにせんとな。で、もう1つ質問』
「はい、どうぞ」
『この構文、フェリちゃん입上でもロヴィ입上でも見たことあらへんよ。
　これ以外に簡単なビットの立て方あるんちゃうの？』
「……こういう時には鋭いですね。はい、御座いますとも。
　一番最初にこの講座で説明した、論理演算子|は覚えていますか？」
『忘れるわけないやん？　どっちかを満たせば1を返すから、0と0以外なら絶対に1に……あ！？』
「ええ。お察しの通りです。この記号・|を用いればビットを立てるくらい楽勝ですよ。
　変数同士の발し算を A += B と記述するのは解ってますよね？　その原理で――」

A |= 2

「と書けば、簡単にビットを立てることができます」
『何せ絶対に1になるんやもんな。これで立てる方はバッチリや』
「はい……で、問題がビットクリアなんですよね」
『どんな問題があるん？』
「eramakerで使える論理演算子が&か|しかないことです。普通のビット演算では」

A & ~B

「っていう風に記述すれば、Bビット目を落としてくれるんですけど……」
『~って、&でも|でもないっちゅーことは使えへんやん』
「そうなんですよね。という訳で、こちらはEmuera用になります」
『じゃあどないすんの？　立ったら立ちっぱなし？』
「いえ、ちょっとややこしいだけです。まずは、最初にビットを立てる方法で使った技の応用」

SIF A & 2
	A -= 2

「これなら2ビット目が立っている時だけ2ビット目を落とす事が出来ます」
『成程な……でもこれ、ロヴィ입上で見たことないわ。やっぱり楽な方法あるんと違うの？』
「楽……ですかねえ」
『ん？』
「見て貰えば解りますよ。ロヴィーノ입上の指定ビットクリア作業は、こんな風にしてあります」

A &= 最大使用ビット（10進数） - 落としたいビット（10進数）

『……は？　何やのこれ』
「こんな風にも書けます、ってぐらいで覚えておいてください。
　計算間違えるとバグるんでお勧めはしません。
　입上主は『1行で書けるから』ってだけでこう書いてるだけですし」
『一応、何が起きるんかだけ説明してくれん？』
「そうですね……例えば、ロヴィーノ입上では今の所最大16ビット――131071を想定しています。
　ここから10ビット目、1024を寝かせたい時は、131071 - 1024 = 130047。これを&で判定すれば……」


  11111110111111111
 &    XXXXXXXXXXXXX
-------------------

「こうすれば、&判定の仕様で例え10ビット目が1だろうが0だろうが絶対に0になります。
　他のビットは1なら1同士で1は残り、0なら1と0の組み合わせになるから0のまま残る。
　つまり、指定したビットだけ落としてあとは残す事が出来るんです」
『……あかん、さっぱり解らんくなってきたわ』
「ここまで来ると習うより慣れろですよ。
　ビット演算は講座だけ読んで理解できるような生易しいものじゃありません。
　この講座をここまで読んだ貴方なら理解できるはずです。
　さぁ、ビット演算を実際に使用しているファイルや입上を解読してみましょう！」


「あ、言い忘れてました。全部のビットを一気に落としたいなら、A = 0で構いませんよ」
『毎回毎回リセットするようなフラグはそうすればええんやな？』
「あとは……植物に水を上げるとか、ペットに餌をあげるとか。
　日付が変わるごとにまた0にしたいフラグなんかは、そう処理すればいいんじゃないでしょうか」



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【ビット演算を使ったイベントについて】
-------------------------------------------------------------------------------

『で、このビット演算やけど――具体的にどう使えばええのん？』
「そうですね。この講座書いてる人が全てのerahetaA입上職人さんに
　是非とも実装していただきたい個所がひとつあります」
『偉そうに。何やの、言ってみいや』
「拷問입上」
『は？』
「拷問입上で、이상경험が入るパターンを設定している方がいるでしょう？
　あそこで是非このビット演算をご利用していただきたいんです。
　ところで、今この場で適当な입上ファイル確認していただければ解るんですが、
　結構な方が『기절するまで殴るのは異常』という理由で無意識のビット演算をしてるんですよ。
　でも見れば解る通り、実際にCFLAG:12の2ビット目を立ててる方は一人もいません。
　という訳で、現状では見たら見ただけ何回でも이상경험が入ってます。
　입上主のロヴィーノ君がそれだけで皆さんの이상경험を5～10回ほどにしたので調査は完璧です」
『ちょい待ちいや、俺の子分に何させとんの！？』
「それはそうとこのCFLAG:12ですが、erahetaAでは労役中フラグとして使用中です。
　労役中は当然調教が行えませんので、普通にやってたらこのビット演算は正常に動作しません」
『えええええ！？』
「なので、あの部分を――」

;（プレイ内容）は이상경험なので点を入れる
IF (適当な空きフラグ & 空いてるビット) == 0
	PRINTFORML %EXPNAME:50%＋1
	EXP:50 += 1
	適当な空きフラグ |= 空いてるビット
ENDIF

「としないと、意味ないんですよ」
『……何で今まで誰も気づかなかったんや』
「それだけビット演算の敷居が高かったって事じゃないでしょうか。
　今までの説明だけでこの辺りは簡単に改造できるはずですから、まずはここから挑戦してみてください」

「――そうそう、이상경험を入れるイベントがたくさんあるという方なんかは、
　イベントに応じてビットの位置をズラして下さいね。
　じゃないとＡプレイで이상경험が入った후にＢプレイをやった時、
　同じビット位置で判定をしていると意図した挙動をしてくれません。
　このあたりの挙動に関してはSTAIN変数を思い出していただければいいんじゃないかと」
『あー、ビット演算はいつ起きるか解らんイベントの制御も出来るんやな』
「はい。単純なスイッチのオンオフだけじゃなくて、
　調教100回目記念とか……そういった『いつ来るか解らないフラグ』の判定にも向いてますね」
『ヘタしたら친애付く前に100回通ってまうかもしれんしな』
「ロヴィーノ君입上のCFLAG使用表が解読できれば、ビット演算で出来る事の大半は理解できます。
　頑張って読み解いて下さい。コンフィグ的な使い方からイベントまで、色々やってますから」



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【終わりに】
-------------------------------------------------------------------------------

IF CFLAG:208 & 1
	PRINTFORML 「じゃーん。前にもらった奴着てみたよー。恥ずかしいけど似合ってるかなー」

「これ、もう読めますよね」
『CFLAG:208の1ビット目が立ってれば、フェリちゃんが선물した服を着てくれるんやな。
　で、肝心のCFLAG:208は선물コマンドでビットを立てるようになっとる』
「そうそう、完璧じゃないですか！」
『しかし……なんか物凄い頭の痛い講座やったわ』
「まあ……使えば面白くなるという技術でもないので、無理して覚えなくても結構ですよ。
　最低限STAIN変数の使い方さえ解るようになったなら万々歳じゃないでしょうか」
『そんなもんやの？』
「そんなもんです。新機能もミニゲームも、作ったから必ず面白いって訳じゃないでしょう？
　特にミニゲームなんか作る側からすれば全くミニじゃありませんよ」
『それはそうなんやけど……』
「使えば便利になるのは確かです。ま、今までの話は小耳にでも挟んでおいて下さいな。
　(STAIN:7:4) != 0で발に精液汚れがあるかどうかを確かめられる。
　この機能さえ覚えておけばばっちりですよ」
『全然大丈夫な気がせえへんのやけど』
「解らない事があればまた聞いて下さい。答えられる限りならお答えしますから――
　という訳で、今回の講座はここでお開きにしましょうか」
『せやな。ほんじゃ、お疲れさん！』







-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【후書き】
-------------------------------------------------------------------------------

物凄く解りづらい講座になってしまい申し訳ありません。
でも、これが私の出来る精一杯でした。


■参考にした講座
・もこてる講座
・ゆかりんとてんこのビット演算講座

両方ともeratohoまとめwiki、開発用ツールページでダウンロードできるビット演算講座です。
この講座より数倍解りやすいと思われますので、是非ご覧ください。

・eratohoまとめWiki  ERB構文講座特別編
・era本家「漠々ト、漠」 eramaker era basic変数リスト（暫定版） 

ここ見ないと恐らく意味不明。


■このファイル内で話題に出させていただいた입上
フェリシアーノ입上中心に、ほぼ全てのerahetaA입上

無断ネタ出しで申し訳ございません。
いつもお世話になっております、本当に有難うございました。



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
【補講】
-------------------------------------------------------------------------------


『なんか言い忘れがあったんやって？』
「はい。3つほど……まず、A & 3 == (A & 1 || A & 2)になる事の説明を忘れてました」
『式だけやと意味不明やな』
「証明は各個人にお任せします。とりあえず原理から言うと……
　A & 3が0になるのはAがどんな時でしたっけ
『1、2ビット目の両方が落ちとる時……ああ、どっちかが立っとったら0にはならへんね』
「という訳で、A & 3 == (A & 1 || A & 2)になります。気を付けて下さいね。
　そうそう、今更なんですけど……」

IF TALENT:A

「などの==を使わない条件式は『0以外である』の意なので、1だろうと2だろうと-1だろうと反応します」
『以外と知らん人が居るから一応、な。あとは何の話なん？』
「えーと……ビットを落とす際の
　『A &= 最大使用ビット（10進数） - 落としたいビット（10進数）』
　という説明が大事なところかっ飛ばし過ぎてて、正確な意味が伝わってなかったので補발をと」
『っていうか、ここはハナから計算式が間違ってたんやろ？』
「思いっきり違いました。11/21以降からは修正入ってます。
　補講ですので詳しく補講させて頂きますと、あれは使用しているビットの最大数 - 落としたいビットなんです」
『例えば最大使用ビットが12ビット――4096なら、ビットの最大数は1 + 2 + 4 + ～中略～ + 4096で8191やな』
「はい、という訳でお間違いのないようにお願いいたします。幾つか例を上げると――」


・最大使用ビットは16ビット目(65536)と仮定する = ビットの最大値は131071

FLAG:1の10ビット目(1024)を0にする
FLAG:1 &= 130047 ( = 131071 - 1024 )

FLAG:1の0～5ビット目(1+2+4+8+16+32)を全て0にする
FLAG:1 &= 131008 ( = 131071 - 63 )


「というような形になりますね」
『ビットの最大数って簡単に求められる方法あらへんの？　一々발すの面倒なんやけど……』
「最大使用ビット * 2 - 1でどうぞ。あと、この方法だと『現在の最大使用ビット』で計算するので、
　その후の拡張如何ではバグる두려움があるのにもご注意ください」
『今は4096までしか使っとらんでも、いつ8192に손出すか解らんもんね』
「はい。現にロヴィーノ君입上、カツカツでもうすぐ全書き直しになりそうです。
　ビット演算してるフラグが2つほどあるんですが、両方あと2ビットずつしか余裕ありません」
『合計32ビット既に使い潰したんかい……』

「最후に、ビット演算を使う場合は必ず使用法をreadmeかファイル内に書き留めて下さい。
　ビット演算はただでさえ複雑なフラグ管理をより一層スパゲッティなものに変えます。
　후から見た입上加筆及びパッチ製作者の方にも解るように、ひとつひとつまとめて下さい」
『ちゃんとメモっとかんと自分も混乱してまうしな』
「そういう事ですね。それでは、皆様楽しいビット演算ライフをお送り下さいませ」

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
